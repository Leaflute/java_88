 1번. 자료형
    /* 1. 기본 자료형(Primitive Type) : 실제값이 저장
     *    정수형 : byte(1바이트) -> short(2바이트) -> int(4바이트) -> long(8바이트)
     *    실수형 : float(4바이트) -> double(8바이트)
     *    문자형 : char(2바이트)
     *    부울형 : boolean(true/false)
     *       
     * 2. 참조형(Reference Type) : 실제 객체를 가리키는 주소값 저장
     *     클래스, 인터페이스, 배열      
     * 
     * 3. 문자열 : String 클래스 
     */
 
 2번. 상수
 	/*
     * 상수 : 프로그램이 실행되는 동안, 값이 변하지 않는 수 또는 변경불가능한 수
     *      final 키워드는 변수에 값이 대입되고 나면, 변수값이 더이상 변경되지 않는다는 의미
     *      주로 대문자를 사용
     *      만일 값변경시 상수를 선언한 부분의 값만 변경한다. 
     * final  p305
     * 1) 변수(상수) : 변수에 값 대입불가
     * 2) 메서드 : 재정의 불가
     * 3) 클래스 : 상속 불가
     */
   final double PI = 3.14;  // 상수선언 및 초기화  .. 면접

3번. 구구단 예제
   for / while

4번. 객체 설명
   /*        
    *  인스턴스 생성 : 클래스명 참조변수명 = new 클래스명();    // new 생성자;
    *        접근 : 참조변수명.멤버변수
    *             참조변수명.멤버메서드;
    *  - 참조변수명에는 생성한 인스턴스의 힙 메모리공간 주소값이 들어있다. 기본타입은 스택메모리에 생성.
    *    앞의 클래스명은 데이터타입이고, 참조변수로 접근할 때 사용한다.
    *    뒤의 클래스명은 힙메모리에 인스턴스 생성시 사용되는 생성자이다.   
    *  클래스 : 객체에 대한 설계도, 디자인
    *       -멤버변수(속성, 필드) + 멤버메서드(기능, 동작) + 생성자
    *       
    *  클래스는 설계도(디자인)이며, 인스턴스는 이 설계도를 바탕으로 만들어진 힙메모리 공간이다.
    *        그 결과 주소값이 만들어지며, 참조변수에 할당된다.
    *        객체는 인스턴스라고도 한다.
    */ 
    
5번. setter / getter

6번. 생성자 오버로드와 상속 오버라이딩의 차이점
	생성자 오버로드 : 생성자가 두 개 이상 제공되는 경우를 생성자 오버로드라 함
   	메서드나 생성자의 매개변수 갯수가 다르거나, 매개변수 타입이 다른 경우 (단, 리턴타입은 무관)
   	
   	/*
	 * p250 [면접] 오버로드 vs 오버라이드
	 * @Override 어노테이션 : "이 메서드는 재정의된 메서드입니다."라고 컴파일러에게 명확히 알려주는 역할을 한다.
	 * 오버라이딩(=재정의)
	 * 자식 클래스의 메서드가 부모클래스의 메서드를 오버라이드(재정의)한다
	 * 상속에서 부모클래스의 메서드를 변경하고자 할 때 사용한다
	 * 메서드 이름, 매개변수, 매개변수 자료형, 반환형까지 모두 동일해야 한다.(동일하지 않으면 컴파일러가 다른 메서드로 인식한다.)
	 * 호출시 오버라이드한 자식메서드가 호출된다.
	 * 오버라이드 목적: 부모클래스의 메서드를 변경해서 자식쪽에서 호출하고자 함
	 * 사전적인 의미: 부모메서드의 기능을 무시한다.
	 */
   	
7번. static 변수

      /*
       * static 변수 = 정적변수 = 공유변수 = 클래스변수
       * static 변수 :
       * - 프로그램이 실행되어 메모리에 올라갔을 때 딱 한번 데이터영역 메모리 공간에 할당된다.
       * - 객체를 생성하지 않고, 바로 클래스명으로 접근가능하다.
       *   인스턴스마다 생성되는 변수가 아니라, 클래스에 속해 한번만 생성되는 변수이고, 여러 인스턴스가 공유하기 때문이다.
       *   인스턴스가 생성되지 않아도 사용할 수 있기 때문에 클래스명.멤버변수, 클래스명.멤버메서드 사용가능
       *   
       * - static 변수나 메서드는 static 메서드에서 호출가능
       * (정적메서드에서 인스턴스 변수나 메서드를 호출시 컴파일 오류가 난다.)
       * static 메서드는 프로그램 실행시 자동으로 메모리에 올라가나, 일반메서드는 객체를 생성해야 메모리에 올라간다.
       * 
       */
       
8번. 싱글톤 패턴
	/*
	 * [면접] p193
	 * - 동일한 인스턴스를 단 하나만 생성하는 디자인 패턴
	 * - 접근할 클래스에 여러 메서드가 있을 때, 외부 클래스가 해당 메서드에 접근할 때마다 
	 * 인스턴스를 생성할 필요없이 getInstance()를 통해 참조변수만 리턴받아 접근한다
	 * 몇 번을 호출해도 항상 같은 주소의 인스턴스가 반환된다.
	 * 
	 * - 싱글톤패턴 생성
	 * - 1. 생성자를 private로 만들기
	 * - 2. 클래스 내부에 static으로 유일한 인스턴스를 생성
	 * - 3. 외부에서 참조할 수 있는 public메서드 만들기
	 * 
	 * - 호출 방법
	 * - 접근클래스명 참조변수 = 접근클래스명.getInstance();
	 * 예) _07_Company company = _07_Company.getinstance(); // 클래스명.메서드명
	 */
	 
9번.	상속
	/*
	 * [면접]
	 * 상속: 자식클래스 extends 부모클래스 {}
	 * extends : 확장하다의 의미
	 * 공통으로 사용하는 멤버변수와 멤버메서드를 부모클래스에서 정의한다.
	 * 부모클래스는 일반적이고 공통적이며, 자식클래스는 구체적이며 유일하다.
	 * 부모클래스의 멤버변수와 멤버메서드를 재사용하기 위해 씀
	 * 
	 * 중복되는 코드를 줄여서 손쉽게 개발, 유지보수 
	 * 
	 * 부모클래스의 멤버를 private로 선언한 경우, 자식클래스에서 접근할 수 없다.
	 * 접근제어자가 protected면 자식클래스에서 접근 가능함.
	 */
	 
10번. 
      call by reference // 매개변수 타입이 참조 타입인 경우, 메서드 호출시 매개변수에 주소 전달 
      call by value // 매개변수 타입이 기본 타입인 경우 ,메서드 호출시 매개변수에 값을 전달 - setter, 매개변수 생성자	 
	 
11번. 추상클래스
	/*
     * 추상이란?
     * - 여러가지 사물이나 개념으로부터 공통이 되는 특성을 파악하는 것을 말한다.
     * 
     * [면접]
     * 1. 추상클래스 => 작업명세서
     * - 하나 이상의 추상메서드를 가지고 있는 클래스를 의미한다.
     * - abstract 키워드를 이용하여 구현되지 않는 추상메서드를 기술할 수 있다.
     * - 자식클래스에게 구현을 위임하고자 할 때 사용되며, 프로그램의 확장성을 취해 많이 사용하는 설계방법이다.
     * - 추상클래스는 일반메서드, 추상메서드 모두 올 수 있다.
     * - 전제조건은 반드시 상속을 해야 한다.
     * - 다형성 적용 가능하다.
     * 
     * - 문법 : public abstract class 클래스명 {
     *             public abstract 반환형 메서드명();  // 추상메서드
     *       }
     * 
     * 2. 추상메서드
     * - 하위클래스가 어떤 클래스냐에 따라 구현코드가 달라지며, 하위클래스에 구현을 위임하는 것이다.
     * - 미완성되어있는 메서드이며, 몸체가 없는 메서드로서 항상 세미콜론(;)으로 종료되어야 한다.
     * 
     *  3. 추상클래스의 상속
     *  - 추상클래스를 상속받은 자식클래스는 추상메서드를 반드시 재정의(Override) 해야 하며,
     *    재정의하지 않으면 컴파일 오류가 발생한다.
     *  - 자식클래스에게 강제성과 통일성을 줄 수 있다.(협업시 작업명세서)  
     *       
     * 4. 추상클래스의 객체 생성
     * - 추상클래스는 객체를 생성할 수 없으며(추상 메서드 때문), 상속 계층에서
     *   추상적인 개념을 나타내기 위한 용도로 사용한다.
     * - 상속을 통하여 자식클래스에서 추상메서드를 구현하고, 자식클래스 객체를 생성하여 메서드를 접근할 수 있다.  
     * 
     */
     
12번 인터페이스

	/*
     * [면접] 추상클래스 vs 인터페이스
     *       인터페이스 설명
     *       
     *  인터페이스 
     *  - 기능정의서(표준 작업명세서)이다. - 강제성과 통일성
     *  - 설계(선언)와 구현을 분리시키는 것을 가능하게 한다.
     *    (설계 : 인터페이스, 구현 : 자식클래스)
     *  - 객체(인스턴스)생성 불가능하며, 객체 Type으로 가능하다.(다형성 적용)
     *  - 인터페이스의 멤버는 상수(static final 생략 가능), 추상메서드(abstract 생략 가능)만 올수 있다.
     *  - 단 static 메서드, 디폴트 메서드, private 메서드는 예외(JDK 1.8부터)
     *  - 인터페이스를 implements(=구현)할 자식클래스에서 추상메서드를 재정의한다.
     *  
     *  1. 인터페이스 작성
     *  interface 인터페이스명 {
     *     // 상수
     *     public static final 데이터타입 대문자상수명 = 값;
     *      // 추상메서드
     *      public 반환형 추상메서드(매개변수1,...);  // body없다
     *  }
     *  
     *  2. 인터페이스 구현
     *  class 클래스명 implements 인터페이스명{
     *     @Override
     *      public 반환형 추상메서드(매개변수1,...) {
     *          // 인터페이스에 정의된 추상메서드를 구현해야 한다.
     *       }
     *  }
     * 
     * 3. 인터페이스는 다중 상속 가능    cf) 클래스는 단일 상속만 가능
     * interface 인터페이스명  extends  인터페이스명1, .. 인터페이스명n {
     * 
     * }
     * 
     * class 클래스명  extends  클래스명1, .. 클래스명n {  //NG - 클래스는 단일 상속만 가능
     * }
     * 
     * 4. 상속과 구현을 동시
     * class 클래스명 extends 부모클래스 implements 인터페이스명1, .. 인터페이스명n {
     * 
     * }
     * 
     * 5. 예외
     * 자바 8부터 디폴트(default) 메서드, 정적(static) 메서드 구현이 가능
     * 자바 9부터 private 예약어를 사용한 메서드 구현 가능
     */
     
13. ArrayList
	/*
     * 컬렉션 프레임워크
     * 
     * Collection 인터페이스
     * - List 인터페이스 : 클래스 종류는 ArrayList, Vector, LinkedList
     * - Set 인터페이스 : 클래스종류는 HashSet, TreeSet
     * - Map 인터페이스 : 클래스종류는 HashMap, HashTable, TreeMap
     * 
     *  <면접>
     *  1. 특징
     *  List 인터페이스 : 순서가 있는 자료관리, 중복허용한다.
     *                 index를 사용하여 요소에 접근한다.
     *                 리스트에 들어있는 요소들의 인덱스는 0부터 시작한다. 
     *                 클래스종류는 ArrayList, Vector, LinkedList
     *                 
     *  Set 인터페이스 : 순서가 없는 자료관리, 중복허용 않는다.
     *                클래스종류는 HashSet, TreeSet
     *                
     * [ArrayList]
     * 2. 선언           
     * ArrayList<데이터타입클래스> 참조변수 = new ArrayList<데이터타입클래스>();
     * 
     * 다형성 적용
     * List<데이터타입클래스> 참조변수 = new ArrayList<데이터타입클래스>();
     *
     * 3. 특징 : 데이터 순서가 있고, 중복허용된다.
     * 4. 추가 : list.add(값);   // 앞에서부터 순서대로 추가
     *         list.add(추가할 위치 index, 값);  // 지정한 인덱스에 값을 추가, 그 뒤값은 밀려난다.
     *         
     * 5. 값 가져오기 : list.get(가져올 index);  // list.size() 만큼 반복    
     * 6. 교체 : list.set(교체할 위치 index, 값);  // 지정한 인덱스의 값을 변경.. 그 뒤값은 그대로이다.
     * 7. 삭제 : list.remove(삭제할 위치 index);
     * 8. 검색 : list.indexOf(검색할 값);  // 중요
     *          리스트에서 검색할 값과 똑같은 값을 갖는 첫번째 데이터를 찾아서 그 위치의 인덱스를 리턴한다.
     *          검색할 값과 일치한 데이터가 없으면 -1을 리턴한다.
     * 9. 전체 삭제 : list.clear();
     * 10. 반복자 : Iterator<E> iterator : while(hasNext()) { next() }          
     */
     
14. HashMap  
		
		/*
		 * [면접] p439
		 * 해싱(hashing): key를 이용해서 hashtable로부터 데이터를 가져오는 과정
		 * 
		 * HashMap
		 * 1. 특징
		 * - 데이터의 순서를 보장하지 않음
		 * - key와 value의 한 쌍으로 되어 있음
		 * - key는 중복될 수 없음
		 * - key를 이용해 value를 반환할 수 있음
		 * - List 계열과 달리 index가 없다.
		 * - Map이라는 인터페이스를 구현한 클래스이다.
		 * 
		 * 2. 선언(문법)
		 * - HashMap<key 타입, value 타입> map = new HashMap<key 타입, value 타입>();
		 * - Map<key 타입, value 타입> map = new HashMap<key 타입, value 타입>();	// 다형성 적용
		 * 
		 * 3. 메서드
		 * - 데이터 추가: put(key, value);
		 * - 데이터 반환: get(key);
		 * - 데이터 삭제: remove(key);
		 * - 데이터 공란 여부: isEmpty();
		 * - 키 공란 여부: containsKey(key);
		 * - 값 공란 여부: containsvalue(value);
		 * - 갯수 체크: size();
		 * 
		 */         
		 
15. 예외처리	
		/*
		 * p487
		 * [면접]
		 * 예외 처리 목적: 정상종료
		 * 
		 * - 문법
		 * try { 
		 * 		// 예외가 발생할 수 있는 코드 부분
		 * } catch (처리할 예외타입 e) {
		 * 		// try 블럭 안에서 예외가 발생했을 때 예외를 처리하는 부분
		 * } finally {
		 * 		// 항상 수행되는 부분(예외가 발생하지 않더라도), 주로 자원해제를 위한 close() 문장이 온다.
		 * }
		 * 
		 */	 
		 
16. 제네릭
		/*
		 * [면접]
		 * - Generic 
		 * 여러 참조 자료형이 쓰일 수 있는 곳에 특정 자료형을 지정하지 않고
		 * Generic 클래스의 인스턴스 생성시점에 어떤 자료형을 사용할 것인지 지정하는 방식
		 * 
		 * - 제네릭 클래스의 선언
		 * 클래스명<매개변수 자료형 알파벳 대문자> 
		 * T(type parameter), E(elements), K(key), V(value), N(number)
		 * 
		 * - 제네릭 클래스의 활용
		 * 인스턴스 생성(new)시 reference type을 대입해 자료 타입을 확정해 사용함.
		 * 
		 * - 제네릭을 구현하면 형변환을 하지 않아도 된다.(다형성 적용과 다운 캐스팅에 신경쓸 필요가 없음)
		 * 
		 * - 제네릭 클래스와 static 
		 * T의 자료형이 정해지는 순간은 제네릭 클래스의 인스턴스가 생성되는 순간임
		 * 따라서 static은 T의 자료형이 결정되는 시점보다 빠르기 때문에 인스턴스 생성시점에 static에 들어가지 않으면 활용불가
		 */	
		 
17. 쓰레드

	/*
	 * [면접]
	 * Thread 생성과 실행
	 *
	 * (1) Thread 클래스를 상속하기
	 * 
	 * 1. Thread 클래스를 상속받아서 클래스를 작성한다.
	 * 2. run() 메서드를 재정의 
     * 3. main() 메서드에서  Thread라는 객체를 생성한다.
	 * 4. start() 메서드 호출해서 스레드를 실행한다.
	 * 5. run() 메서드가 실행된다.
	 * 
	 * (2) Runnable 인터페이스 구현
	 * 
	 * 1. Runnable 인터페이스를 implements 받아서 클래스를 작성한다.
	 * 2. 추상메서드 run() 메서드를 재정의 
	 * 3. main() 메서드에서  Thread라는 객체를 생성하고, implements받은 클래스 객채를 매개변수로 전달
	 * 4. start() 메서드 호출해서 스레드를 실행한다.
	 * 5. run() 메서드가 실행된다.
	 * 
	 */